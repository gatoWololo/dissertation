\chpt{Conclusion}
This dissertation overviews techniques for low-level process manipulation. We argue process manipulation is a useful and generalizable technique with many applications in software systems. Our introduction gives an overview of program tracing and low-level process manipulation. Then, we summarize system call interposition and the Linux ptrace API. We show how the low-level primitive operations provided by ptrace can be used to build useful, reusable program manipulation constructs such as arbitrary system call injection, system call replay, and system call modification. 

Afterwards, we see an application of low-level process manipulation towards solving an existing issue in software systems: software reproducibility. We describe the design and implementation of \dettrace, which provides a new \emph{reproducible container} abstraction. \dettrace automatically provides reproducibility for software builds, bioinformatics processing and ML workflows without requiring any changes to the hardware, OS, or application code. \dettrace{} shows the utility of low-level process manipulation by implementing a dynamic determinism enforcement mechanism on top of it. Process manipulation is orthogonal to other OS-level techniques. So it can be readily combined with other OS-level facilities, e.g. containerization. Dettrace further implements a userspace, reproducible, thread and process scheduler via ptrace.

\dettrace has several avenues for future work. \dettrace guarantees reproducible execution of threads by sequentializing thread execution within   a process. This method does not always work, for example the Java virtual machine deadlocks during garbage collection under \dettrace. Furthermore, sequentializing thread execution incurrs high performance overhead due to the loss of parallel execution of threads. This motivates two avenues for future work: First, Dettrace could relax constraints such as thread sequentializing via command line options when the user knows a priori that thread execution will not cause issues. This could be generalized to other areas of \dettrace{} to allow users to pick and choose which parts of \dettrace{}'s determinism enforcement their application requires. This would minimize the performace cost incurred by our dynamic determinism enforcement while simultaneously allowing more programs to execute under \dettrace{}. Second, \dettrace{} could look into generalizing its methods to support parallel and deterministic thread execution. \dettrace may be combined with relevant work in this area.

\dettrace motivated many ideas and future work directions, among the the \pc{} project. \pc{} attempts to automatically cache and skip unnecessary process-level computations. \pc{} traces the execution of programs to determine the program's input and outputs, caching the outputs. When this program is re-executed, \pc{} will skip any processes whose inputs have not changed and use the cached output instead. \pc{} represents the most advance use of the process manipulation techniques we have developed. Its implementation is informed by experience working on \dettrace{}. \pc{} in turn has informed the future work section, specially Section \ref{sec:betterPtrace}.

There are several avenues for future work as a follow up to \pc{}:
\begin{compactitem}
  \item \pc{} could be generalized to support multiple users within the same machine, this would allow the cache to be shared and used by multiple users.
  \item An even larger leap would be to make \pc{} fully distributed allowing cached results to be shared across machines and users, a la Google's distributed builds infrastructure \cite{distributed-google}. 
  \item \pc{} currently hashes file contents to detect if file contents have changed. This incurs a non-trivial performance penalty. \pc{} can fall back to using mtimes on files for faster file change detection. mtimes do not always reliable and are not portable across machines. A better way to detect file changes would be to rely on file change mechanisms like inotify. \pc{} could be modified to have a daemon responsible for keeping track of file changes.
\end{compactitem}

  Furthermore, \pc{} is quite the engineering effort and requires further work to be turned into a useful production system. I suspect interesting and novel research questions would arise during this implementation effort.

Tracing is useful at many levels of the software stack. Working strictly with OS-level tracing and process manipulation can create difficulties. We find this is not always the right level of abstraction. This motivated Tivo and lightweight record-and-replay (RR). Lightweight RR is a hybrid approach between heavyweight, fully deterministic systems, and no determinism enforcement. Lightweight RR is designed to empirically lower the amount of intermittent test failures in a program's test suite, while enjoying minimal performance overhead and record-log sizes. Lightweight RR has exciting and promising future work avenues beyond the just our current use in Tivo. With more work, I believe lightweight RR could prove to be a useful tool for the development and debugging of concurrent systems and asynchronous programming models.

Finally, the future work chapter sketches the design for a novel system for automatic fault discovery. ChaOS utilizes low-level process manipulation techniques developed in our other work to implement a fault injection tool for system calls. ChaOS proposes using many of the process manipulation techniques developed during the course of my PhD. Including system call modification and system call injection. Specifically, ChaOS injects fork/clone system calls to make copies of the tracee. This allows us to effectively save the state of the currently executing tracee.

Our future work also overviews different tracing and process manipulation implementations commonly used. We compare advantages and shortcomings of each approach. Then, we propose key features next generation tracing and process manipulation implementation should support. It is unclear if any implementation could satisfy all the key features at the same time. As a stop gap, I propose a higher-level library, \code{libptrace}. \code{libptrace} is partially inspired by \code{libseccomp} a higher-level library build on top of Linux seccomp. \code{libseccomp} abstracts over many idiosyncrasies and low-level details of seccomp, creating a more accessible and useful library. The design and implementation of \code{libptrace} has similar goals: providing a high-level easy to use tracing and process manipulation library built on top of ptrace. \code{libptrace} provides a asynchronous IO abstaction allowing code to be written in a sequential manner. It is my hope higher-level and abstracted tracing and process manipulation mechanism will bring accessibility and allow more people to use these powerful techniques.